üåç Community
=============

Submitting Issues, Ideas, & Suggestions
----------------------------------------

*Have an issue? Seeking Support?*
- `Open a GitHub Issue <https://github.com/kylejgillett/sounderpy/issues>`_
- Shoot me an email! (kyle.gillett@und.edu)
- Shoot me a DM on X (@wxkylegillett)


Contributing to SounderPy
-------------------------

Contributions to this library are encouraged! Below are a few simple guidelines to follow if you are considering helping out this package.

- **Tackling open issues on Github** --  feel free to search through unresolved `Github Issues <https://github.com/kylejgillett/sounderpy/issues>`_ and propose a solution!
- **Contributing your code** -- if you have made local modifications to SounderPy, feel free to suggest adding your changes by opening a `GitHub pull request <https://github.com/kylejgillett/sounderpy/pulls>`_.
- **Adding an entirely new feature** -- similarly to above, open a `GitHub pull request <https://github.com/kylejgillett/sounderpy/pulls>`_ with the proposed additions.
- **Creating tutorials** -- So much of the code we write is best understood with comprehensive tutorials. I highly encourage anyone to build tutorials that explain the code, explain a specific use/task, or to simply provide more examples. Do so by opening a `GitHub pull request <https://github.com/kylejgillett/sounderpy/pulls>`_.


**To contribute to SounderPy...**

1. In GitHub, fork the SounderPy repository (repo) into your profile.
2. Pull down the forked repo to your local machine.
3. After making changes, commit them to your forked repo.
4. Finally, open a Pull Request.

    - Pull requests, for any contribution, should include a detailed explanation of the code, why it's needed, and what it fixes/replaces.
    - Ensure that your code is well formatted, clean, commented and easy to read.
    - **IMPORTANT**: The goal of SounderPy is to make sounding analysis available to everyone -- beginners and experts alike. As such, SounderPy code should be *easy to read*, not just well-documented. In the case of this library, code that is clean and *easy to read* is valued more over code that is "fancy", "too-complex" and harder to read.